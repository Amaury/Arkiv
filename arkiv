#!/bin/bash

# ARKIV
#
# Simple file archiver, designed to backup local files and MySQL databases and archive them on Amazon S3.
#
# Source code and documentation: https://github.com/Amaury/Arkiv
#
# © 2017, Amaury Bouchard <amaury@amaury.net>

# Path to the configuration file.
# @see	main_usage()
CONFIG_FILE_PATH="~/.arkiv"

# noansi mode
# @see	main_usage()
NOANSI_MODE=0

# trim()
# Remove spaces at the beginning and at the end of a character string.
# @param	string	The string to trim.
trim() {
	RESULT=$(echo "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
	echo $RESULT
}

# filenamize()
# Convert a string that contains a path to a file, and return a string suitable as a file name.
# Replace slashes and spaces by dashes.
# @param	string	The string to modify.
filenamize() {
	RESULT=$(echo "$1" | sed 's/[[:space:]]\+/-/g' | sed 's/\//-/g' | sed -e 's/^-*//' -e 's/-*$//' | sed 's/-\+/-/g')
	echo $RESULT
}

# ansi()
# Write ANSI-compatible statements.
# @param	string	Command:
#			- reset: Remove all decoration.
#			- bold:  Write text in bold.
#			- dim:   Write faint text.
#			- rev:   Write text in reverse video. Could take another parameter with the background color.
#			- under: Write underlined text.
#			- black, red, green, yellow, blue, magenta, cyan, white: Change the text color.
ansi() {
	if [ "$NOANSI_MODE" = "1" ]; then
		return
	fi
	case "$1" in
		"reset")	tput sgr0
		;;
		"bold")		tput bold
		;;
		"dim")		tput dim
		;;
		"rev")
			case "$2" in
				"black")	tput setab 0
				;;
				"red")		tput setab 1
				;;
				"green")	tput setab 2
				;;
				"yellow")	tput setab 3
				;;
				"blue")		tput setab 4
				;;
				"magenta")	tput setab 5
				;;
				"cyan")		tput setab 6
				;;
				"white")	tput setab 7
				;;
				*)		tput rev
			esac
		;;
		"under")	tput smul
		;;
		"black")	tput setaf 0
		;;
		"red")		tput setaf 1
		;;
		"green")	tput setaf 2
		;;
		"yellow")	tput setaf 3
		;;
		"blue")		tput setaf 4
		;;
		"magenta")	tput setaf 5
		;;
		"cyan")		tput setaf 6
		;;
		"white")	tput setaf 7
		;;
	esac
}

# log()
# Write a character string with the current date before it.
# @param	string	The text to write.
log() {
	CURDATE=`date +"%Y-%m-%d %H:%M:%S"`
	echo "$(ansi dim)[$CURDATE]$(ansi reset) $1"
}

# main_usage()
# Show help and exit.
main_usage() {
	echo
	echo "  $(ansi bold)arkiv$(ansi reset) help|config|exec $(ansi dim)[--noansi]$(ansi reset) $(ansi dim)[/path/to/config/file]$(ansi reset)"
	echo
	echo "                    $(ansi bold)help$(ansi reset)  Display this help."
	echo "                  $(ansi bold)config$(ansi reset)  Create Arkiv's configuration file."
	echo "                    $(ansi bold)exec$(ansi reset)  Backup files and databases, archive them and purge old files."
	echo
	echo "                $(ansi dim)--noansi$(ansi reset)  Don't use ANSI commands to ouput decorated text (colors, bold, reverse video)."
	echo "    $(ansi dim)/path/to/config/file$(ansi reset)  Path to the configuration file to use instead of '~/.arkiv'."
	echo
	exit 0
}

# _create_config()
# Create the content of the configuration file.
# Uses the global variables defined elsewhere ($CONF_LOCAL_HOSTNAME, $CONF_BACKUP_PATH, etc.).
# @param	string	(optional) Visibility. Replace the MySQL password by an informative message if this parameter is set to "hide".
_create_config() {
	RESULT="CONF_FREQUENCY=\"$CONF_FREQUENCY\"
CONF_LOCAL_HOSTNAME=\"$CONF_LOCAL_HOSTNAME\"
CONF_Z_TYPE=\"$CONF_Z_TYPE\"
CONF_BACKUP_PATH=\"$CONF_BACKUP_PATH\"
CONF_SRC=\"$CONF_SRC\"
CONF_MYSQL=\"$CONF_MYSQL\""
	if [ "$CONF_MYSQL" = "yes" ]; then
		RESULT="$RESULT
CONF_MYSQL_HOST=\"$CONF_MYSQL_HOST\"
CONF_MYSQL_USER=\"$CONF_MYSQL_USER\""
		if [ "$1" = "hide" ]; then
			RESULT="$RESULT
CONF_MYSQL_PWD=___HIDDEN_PASSWORD___"
		else
			RESULT="$RESULT
CONF_MYSQL_PWD=\"$CONF_MYSQL_PWD\""
		fi
		RESULT="$RESULT
CONF_MYSQL_ALL_DATABASES=\"$CONF_MYSQL_ALL_DATABASES\""
		if [ "$CONF_MYSQL_ALL_DATABASES" = "no" ]; then
			RESULT="$RESULT
CONF_MYSQL_DATABASES=\"$CONF_MYSQL_DATABASES\""
		fi
	fi
	RESULT="$RESULT
CONF_AWS_S3=\"$CONF_AWS_S3\""
	if [ "$CONF_AWS_S3" = "yes" ]; then
		RESULT="$RESULT
CONF_S3_BUCKET=\"$CONF_S3_BUCKET\""
	fi
	RESULT="$RESULT
CONF_AWS_GLACIER=\"$CONF_AWS_GLACIER\""
	if [ "$CONF_AWS_GLACIER" = "yes" ]; then
		RESULT="$RESULT
CONF_GLACIER_VAULT=\"$CONF_GLACIER_VAULT\""
	fi
	RESULT="$RESULT
CONF_LOCAL_PURGE_DELAY=\"$CONF_LOCAL_PURGE_DELAY\"
CONF_S3_PURGE_DELAY=\"$CONF_S3_PURGE_DELAY\""
	echo "$RESULT"
}

# main_config()
# Manage configuration.
main_config() {
	# splashscreen
	echo
	echo " $(ansi rev)                                         $(ansi reset)"
	echo " $(ansi rev) $(ansi reset)$(ansi rev blue)                                       $(ansi reset)$(ansi rev) $(ansi reset)"
	echo " $(ansi rev) $(ansi reset)$(ansi rev blue)          $(ansi white)$(ansi bold)Arkiv Configuration$(ansi reset)$(ansi rev blue)          $(ansi reset)$(ansi rev) $(ansi reset)"
	echo " $(ansi rev) $(ansi reset)$(ansi rev blue)                                       $(ansi reset)$(ansi rev) $(ansi reset)"
	echo " $(ansi rev)                                         $(ansi reset)"
	echo
	# BASIC
	echo "$(ansi rev yellow) BASIC         $(ansi reset)"
	# daily/hourly
	read -p " $(ansi yellow)Do you want to backup your data every $(ansi bold)day$(ansi reset)$(ansi yellow) or every $(ansi bold)hour$(ansi reset)$(ansi yellow)? [Day/hour] $(ansi reset) " ANSWER
	ANSWER=$(trim "$ANSWER")
	if [ "$ANSWER" = "" ] || [ "$ANSWER" = "d" ] || [ "$ANSWER" = "D" ] || [ "$ANSWER" = "day" ] || [ "$ANSWER" = "Day" ] || [ "$ANSWER" = "DAY" ]; then
		CONF_FREQUENCY="daily"
	elif [ "$ANSWER" = "h" ] || [ "$ANSWER" = "H" ] || [ "$ANSWER" = "hour" ] || [ "$ANSWER" = "Hour" ] || [ "$ANSWER" = "HOUR" ]; then
		CONF_FREQUENCY="hourly"
	else
		echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
		exit 1
	fi
	# local host
	HOST=`hostname`
	if [ "$HOST" = "" ]; then
		HOST="localhost"
	fi
	read -p " $(ansi yellow)Local host name? [$HOST]$(ansi reset) " ANSWER
	CONF_LOCAL_HOSTNAME=$(trim "$ANSWER")
	if [ "$CONF_LOCAL_HOSTNAME" = "" ]; then
		CONF_LOCAL_HOSTNAME="$HOST"
	fi
	# compression type
	read -p " $(ansi yellow)Compression type? (gzip|bzip2|xz) [xz]$(ansi reset) " ANSWER
	CONF_Z_TYPE=$(trim "$ANSWER")
	if [ "$CONF_Z_TYPE" != "gzip" ] && [ "$CONF_Z_TYPE" != "bzip2" ]; then
		if [ "$CONF_Z_TYPE" != "" ] && [ "$CONF_Z_TYPE" != "xz" ]; then
			echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
			exit 1
		fi
		CONF_Z_TYPE="xz"
	fi
	# BACKUP
	echo
	echo "$(ansi rev blue) BACKUP        $(ansi reset)"
	# path to backup
	read -p " $(ansi yellow)Paths (directories and/or files) to backup? (separated with spaces) [/etc /home]$(ansi reset) " ANSWER
	CONF_SRC=$(trim "$ANSWER")
	if [ "$CONF_SRC" = "" ]; then
		CONF_SRC="/etc /home"
	fi
	# MySQL
	CONF_MYSQL="no"
	read -p " $(ansi yellow)Backup MySQL databases? [Y/n]$(ansi reset) " ANSWER
	ANSWER=$(trim "$ANSWER")
	if [ "$ANSWER" = "" ] || [ "$ANSWER" = "y" ] || [ "$ANSWER" = "Y" ]; then
		CONF_MYSQL="yes"
		# check mysqldump
		if ! type mysqldump > /dev/null; then
			echo " $(ansi red)⛔ The 'mysqldump' program is not installed. ABORT$(ansi reset)"
			exit 1
		fi
		# MySQL hostname
		read -p " $(ansi yellow)MySQL hostname? [localhost]$(ansi reset) " ANSWER
		CONF_MYSQL_HOST=$(trim "$ANSWER")
		if [ "$CONF_MYSQL_HOST" = "" ]; then
			CONF_MYSQL_HOST="localhost"
		fi
		# MySQL user
		read -p " $(ansi yellow)MySQL user? [root] $(ansi reset) " ANSWER
		CONF_MYSQL_USER=$(trim "$ANSWER")
		if [ "$CONF_MYSQL_USER" = "" ]; then
			CONF_MYSQL_USER="root"
		fi
		# MySQL password
		read -s -p " $(ansi yellow)MySQL password?$(ansi reset) " ANSWER
		CONF_MYSQL_PWD=$(trim "$ANSWER")
		if [ "$CONF_MYSQL_PWD" = "" ]; then
			echo " $(ansi red)⛔ Empty password. ABORT$(ansi reset)"
			exit 1
		fi
		echo
		# MySQL databases
		read -p " $(ansi yellow)Do you want to backup all databases readable by this user? (otherwise you will have to give a list of database names) [Y/n]$(ansi reset) " ANSWER
		ANSWER=$(trim "$ANSWER")
		CONF_MYSQL_ALL_DATABASES="yes"
		if [ "$ANSWER" = "n" ] || [ "$ANSWER" = "N" ]; then
			CONF_MYSQL_ALL_DATABASES="no"
			read -p " $(ansi yellow)List of databases? (separated with spaces)$(ansi reset) " ANSWER
			CONF_MYSQL_DATABASES=$(trim "$ANSWER")
			if [ "$CONF_MYSQL_DATABASES" = "" ]; then
				echo " $(ansi red)⛔ No database to backup. ABORT$(ansi reset)"
				exit 1
			fi
		fi
	elif [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
		echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
		exit 1
	fi
	# ARCHIVE
	echo
	echo "$(ansi rev magenta) ARCHIVE       $(ansi reset)"
	# local archive path
	read -p " $(ansi yellow)Path to local archives? [/var/archives]$(ansi reset) " ANSWER
	CONF_BACKUP_PATH=$(trim "$ANSWER")
	if [ "$CONF_BACKUP_PATH" = "" ]; then
		CONF_BACKUP_PATH="/var/archives"
	fi
	if [ ! -d $CONF_BACKUP_PATH ]; then
		read -p " $(ansi yellow)Directory '$(ansi reset)$CONF_BACKUP_PATH$(ansi yellow)' doesn't exist. Create it? [Y/n]$(ansi reset) " ANSWER
		if [ "$ANSWER" = "n" ] || [ "$ANSWER" = "N" ]; then
			echo " $(ansi red)⛔ ABORT$(ansi reset)"
			exit 1
		fi
		if ! mkdir -p $CONF_BACKUP_PATH; then
			echo " $(ansi red)⛔ Unable to create directory '$(ansi reset)$CONF_BACKUP_PATH$(ansi red)'. ABORT$(ansi reset)"
			exit 1
		fi
		chmod 600 $CONF_BACKUP_PATH
	elif [ ! -w $CONF_BACKUP_PATH ]; then
		echo " $(ansi red)⛔ Directory '$(ansi reset)$CONF_BACKUP_PATH$(ansi red)' exists but is not writable. ABORT$(ansi reset)"
		exit 1
	fi
	# Amazon S3 + Glacier
	CONF_AWS_S3="no"
	CONF_AWS_GLACIER="no"
	read -p " $(ansi yellow)Archive to Amazon S3? [Y/n]$(ansi reset) " ANSWER
	if [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
		CONF_AWS_S3="yes"
		# check aws-cli
		if ! type aws > /dev/null; then
			echo " $(ansi red)⛔ The 'AWS-CLI' program is not installed. ABORT$(ansi reset)"
			exit 1
		fi
		# Amazon S3
		read -p " $(ansi yellow)S3 Bucket name?$(ansi reset) " ANSWER
		CONF_S3_BUCKET=$(trim "$ANSWER")
		if [ "$CONF_S3_BUCKET" = "" ]; then
			echo " $(ansi red)⛔ Empty bucket name. ABORT$(ansi reset)"
			exit 1
		fi
		# Amazon Glacier
		read -p " $(ansi yellow)Archive to Amazon Glacier? [Y/n]$(ansi reset) " ANSWER
		if [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
			CONF_AWS_GLACIER="yes"
			read -p " $(ansi yellow)Glacier Vault name?$(ansi reset) " ANSWER
			CONF_GLACIER_VAULT=$(trim "$ANSWER")
			if [ "$CONF_GLACIER_VAULT" = "" ]; then
				echo " $(ansi red)⛔ Empty vault name. ABORT$(ansi reset)"
				exit 1
			fi
		fi
	fi
	# PURGE
	echo
	echo "$(ansi rev red) PURGE         $(ansi reset)"
	# local purge
	if [ "$CONF_FREQUENCY" = "daily" ]; then
		# daily backups
		read -p " $(ansi yellow)Delay for local purge?$(ansi reset) $(ansi dim)(examples: \"$(ansi reset)3 days$(ansi dim)\" \"$(ansi reset)2 weeks$(ansi dim)\" \"$(ansi reset)2 months$(ansi dim)\")$(ansi reset) " ANSWER
	else
		# hourly backups
		echo " $(ansi yellow)Delay for local purge$(ansi reset)"
		echo " $(ansi dim)You can give as many delays as you want, separated by semi-colons.$(ansi reset)"
		echo " $(ansi dim)Each delay could be written like:$(ansi reset)"
		echo " $(ansi dim)   - A number followed by a duration. Examples: \"3 days\", \"2 weeks\", \"2 months\"$(ansi reset)"
		echo " $(ansi dim)   - Same as previous, followed by a colon and some hours to purge (separated by comas). Example: \"2 days:02,04,06,08,10;4 days,01,03,05\"$(ansi reset)"
		echo " $(ansi dim)Advice: Even if you purge on different hours, be sure to purge everything after a given delay.$(ansi reset)"
		echo " $(ansi dim)        Like \"2 days:01,03,05,07,09,11,13,15,17,19,21,23;1 week:02,04,06,10,12,14,18,20,22;2 weeks:08,16;1 month"
		read ANSWER
	fi
	CONF_LOCAL_PURGE_DELAY=$(trim "$ANSWER")
	if [ "$CONF_LOCAL_PURGE_DELAY" = "" ]; then
		read -p " $(ansi red)⚠ Are you sure you want to never purge any backup file? [y/N] " ANSWER
		if [ "$ANSWER" != "y" ] && [ "$ANSWER" != "Y" ]; then
			echo " $(ansi red)⛔ Empty purge delay. ABORT$(ansi reset)"
			exit 1
		fi
	fi
	# S3 purge
	if [ "$CONF_AWS_S3" = "yes" ]; then
		if [ "$CONF_FREQUENCY" = "daily" ]; then
			# daily backups
			read -p " $(ansi yellow)Delay for Amazon S3 purge?$(ansi reset) $(ansi dim)(examples: \"$(ansi reset)3 days$(ansi dim)\" \"$(ansi reset)2 weeks$(ansi dim)\" \"$(ansi reset)2 months$(ansi dim)\")$(ansi reset) " ANSWER
		else
			# hourly backups
			echo " $(ansi yellow)Delay for Amazon S3 purge$(ansi reset)"
			echo " $(ansi dim)You can give as many delays as you want, separated by semi-colons.$(ansi reset)"
			echo " $(ansi dim)Each delay could be written like:$(ansi reset)"
			echo " $(ansi dim)   - A number followed by a duration. Examples: \"3 days\", \"2 weeks\", \"2 months\"$(ansi reset)"
			echo " $(ansi dim)   - Same as previous, followed by a colon and some hours to purge (separated by comas). Example: \"2 days:02,04,06,08,10;4 days,01,03,05\"$(ansi reset)"
			echo " $(ansi dim)Advice: Even if you purge on different hours, be sure to purge everything after a given delay.$(ansi reset)"
			echo " $(ansi dim)        Like \"1 week:01,02,03,05,06,07,09,10,11,13,15,15,17,18,19,21,22,23;2 weeks:00,08,16;1 month:12,30;2 months"
			read ANSWER
		fi
		CONF_S3_PURGE_DELAY=$(trim "$ANSWER")
		if [ "$CONF_S3_PURGE_DELAY" = "" ]; then
			read -p " $(ansi red)⚠ Are you sure you want to never purge any archived file? [y/N] " ANSWER
			if [ "$ANSWER" != "y" ] && [ "$ANSWER" != "Y" ]; then
				echo " $(ansi red)⛔ Empty purge delay. ABORT$(ansi reset)"
				exit 1
			fi
		fi
	fi
	# GENERATED CONFIG
	echo
	echo "$(ansi rev green) CONFIG CHECK  $(ansi reset)"
	# create result
	RESULT="$(_create_config hide)"
	# display result
	echo
	echo " $(ansi under)HERE IS THE CONTENT THAT WILL BE WRITTEN$(ansi reset)"
	echo "$(ansi dim)$RESULT$(ansi reset)"
	echo
	# write content
	read -p " $(ansi yellow)Ready to erase file '$(ansi reset)$CONFIG_FILE_PATH$(ansi yellow)' and rebuild it? [y/N]$(ansi reset) " ANSWER
	ANSWER=$(trim "$ANSWER")
	if [ "$ANSWER" != "y" ] && [ "$ANSWER" != "Y" ]; then
		echo " $(ansi red)⛔ ABORT$(ansi reset)"
		exit 1
	fi
	RESULT="$(_create_config)"
	CONFIG_FILE_PATH="/home/amaury/.toto"
	echo "$RESULT" > "$(eval realpath "$CONFIG_FILE_PATH")"
	if [ $? -ne 0 ]; then
		echo " $(ansi red)⛔ Unable to create the file '$(ansi reset)$CONFIG_FILE_PATH$(ansi red)'. ABORT$(ansi reset)"
		exit 1
	fi
	chmod 600 "$(eval realpath "$CONFIG_FILE_PATH")"
	if [ $? -ne 0 ]; then
		echo " $(ansi yellow)⚠ Unable to set access rights of the file '$(ansi reset)$CONFIG_FILE_PATH$(ansi yellow)'.$(ansi reset)"
	fi
	echo " $(ansi green)✓ The configuration file '$(ansi reset)$CONFIG_FILE_PATH$(ansi green)' was successfully created.$(ansi reset)"
	# CRONTAB
	echo
	echo "$(ansi rev cyan) CRONTAB       $(ansi reset)"
	IN_CRONTAB=`crontab -l 2>/dev/null | grep arkiv | wc -l`
	if [ "$IN_CRONTAB" != "0" ]; then
		read -p " $(ansi yellow)Arkiv is already defined in Crontab. Do you want to remove it and re-define it? [Y/n]$(ansi reset) " ANSWER
	else
		read -p " $(ansi yellow)Do you want to add execution in Crontab? [Y/n]$(ansi reset) " ANSWER
	fi
	ANSWER=$(trim "$ANSWER")
	if [ "$ANSWER" != "" ] && [ "$ANSWER" != "y" ] && [ "$ANSWER" != "Y" ] && [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
		echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
		exit 1
	fi
	if [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
		# exec path
		ARKIV_EXEC_PATH="$PWD"
		read -p " $(ansi yellow)Path to the $(ansi reset)Arkiv$(ansi yellow) executable program [$ARKIV_EXEC_PATH]$(ansi reset) " ANSWER
		ANSWER=$(trim "$ANSWER")
		if [ "$ANSWER" != "" ]; then
			ARKIV_EXEC_PATH="$ANSWER"
		fi
		if [ ! -x "$ARKIV_EXEC_PATH/arkiv" ]; then
			echo " $(ansi red)⛔ Unable to find the file '$(ansi reset)$ARKIV_EXEC_PATH/arkiv$(ansi red)'. ABORT$(ansi reset)"
			exit 1
		fi
		# log path
		read -p " $(ansi yellow)Path to log directory? [/var/log/arkiv]$(ansi reset) " ANSWER
		CONF_LOG_PATH=$(trim "$ANSWER")
		if [ "$CONF_LOG_PATH" = "" ]; then
			CONF_LOG_PATH="/var/log/arkiv"
		fi
		if [ ! -d $CONF_LOG_PATH ]; then
			read -p " $(ansi yellow)Directory '$CONF_LOG_PATH' doesn't exist. Create it? [Y/n]$(ansi reset) " ANSWER
			if [ "$ANSWER" = "n" ] || [ "$ANSWER" = "N" ]; then
				echo " $(ansi red)⛔ ABORT$(ansi reset)"
				exit 1
			fi
			if ! mkdir -p $CONF_LOG_PATH; then
				echo " $(ansi red)⛔ Unable to create directory '$(ansi reset)$CONF_LOG_PATH$(ansi red)'. ABORT$(ansi reset)"
				exit 1
			fi
			chmod 770 $CONF_LOG_PATH
		elif [ ! -w $CONF_LOG_PATH ]; then
			echo " $(ansi red)⛔ Directory '$(ansi reset)$CONF_LOG_PATH$(ansi red)' exists but is not writable. ABORT$(ansi reset)"
			exit 1
		fi
		# add to crontab
		if [ "$CONF_FREQUENCY" = "daily" ]; then
			echo " $(ansi yellow)⚠ The execution is set to everyday at midnight. You can change it by editing the Crontab.$(ansi reset)"
			CRONTAB_HOUR="0"
		else
			echo " $(ansi yellow)⚠ The execution is set to every hour. You can change it by editing the Crontab.$(ansi reset)"
			CRONTAB_HOUR="*"
		fi
		(crontab -l 2>/dev/null | grep -v -e "ARKIV" -e "arkiv"; echo; echo "# ARKIV backup"; echo "0 $CRONTAB_HOUR * * * $ARKIV_EXEC_PATH/arkiv exec >> $CONF_LOG_PATH/arkiv.log 2>&1") | crontab -
		# end of process
		echo " $(ansi green)✓ Arkiv was Successfully added to the Crontab$(ansi reset)"
	fi
	# END
	echo
	echo "$(ansi rev) END OF CONFIGURATION    $(ansi reset)"
}

# exec_process()
# Backup files, archive and purge.
exec_process() {
	# get current hour (used during purge process)
	CURRENT_HOUR=`date +"%M"`
	# log
	echo "$(ansi rev)------------------------------------------------------------$(ansi reset)"
	# configuration
	log "$(ansi dim)Read config file '$(ansi reset)$CONFIG_FILE_PATH$(ansi dim)'.$(ansi reset)"
	if [ ! -r $CONFIG_FILE_PATH ]; then
		log "$(ansi red)⛔ Unable to read file '$(ansi reset)$CONFIG_FILE_PATH$(ansi red)'. ABORT$(ansi reset)"
		exit 1
	else
		. $CONFIG_FILE_PATH
	fi
	# create destination directory
	if [ "$CONF_FREQUENCY" = "daily" ]; then
		CURRENT_DATE=`date +%Y-%m-%d`
	else
		CURRENT_DATE=`date +%Y-%m-%d/%H:00`
	fi
	log "$(ansi dim)Create output directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_DATE$(ansi dim)'.$(ansi reset)"
	mkdir -p "$CONF_BACKUP_PATH/$CURRENT_DATE"
	if [ $? -ne 0 ]; then
		log "$(ansi red)⛔ Unable to create directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_DATE$(ansi red)'. ABORT$(ansi reset)"
		exit 1
	fi
	# list of created files
	FILESLIST=""
	# backup files
	if [ "$CONF_SRC" != ""]; then
		log "$(ansi bold)Backup files$(ansi reset)"
		# loop on paths to backup
		for SRC in $CONF_SRC; do
			log "  $(ansi dim)Backup path '$(ansi reset)$SRC$(ansi dim)'.$(ansi reset)"
			FILENAME=$(filenamize "$SRC")
			FILEPATH="$CONF_BACKUP_PATH/$CURRENT_DATE/$FILENAME"
			if [ "$CONF_Z_TYPE" = "gzip" ]; then
				FILE_EXT="tar.gz"
				tar czf "$FILEPATH.$FILE_EXT" "$SRC"
			elif [ "$CONF_Z_TYPE" = "bzip2" ]; then
				FILE_EXT="tar.bz2"
				tar cjf "$FILEPATH.$FILE_EXT" "$SRC"
			else
				FILE_EXT="tar.xz"
				tar cJf "$FILEPATH.$FILE_EXT" "$SRC"
			fi
			if [ $? -ne 0 ]; then
				log "$(ansi yellow)⚠ Unable to compress path '$(ansi reset)$SRC$(ansi yellow)' to '$(ansi reset)$FILEPATH.$FILE_EXT$(ansi yellow)'.$(ansi reset)"
			fi
			# add to list
			FILESLIST="$FILESLIST $FILEPATH.$FILE_EXT"
		done
		echo
	fi
	# backup mysql
	if [ "$CONF_MYSQL" = "yes" ]; then
		log "$(ansi bold)Backup databases$(ansi reset)"
		# fetch the list of databases if needed
		if [ "$CONF_MYSQL_ALL_DATABASES" = "yes" ]; then
			CONF_MYSQL_DATABASES=`MYSQL_PWD="$CONF_MYSQL_PWD" mysql -u $CONF_MYSQL_USER -h $CONF_MYSQL_HOST -e "SHOW DATABASES;" | tr -d "| " | grep -v -e Database -e _schema -e mysql`
			if [ $? -ne 0]; then
				log "$(ansi yellow)⚠ Unable to fetch the list of databases from MySQL.$(ansi reset)"
			fi
		fi
		# loop on databases
		for DB_NAME in "$CONF_MYSQL_DATABASES"; do
			# dump MySQL database
			log "  $(ansi dim)Backup database '$(ansi reset)$DB_NAME($ansi bold)'$(ansi reset)"
			FILEPATH="$CONF_BACKUP_PATH/$CURRENT_DATE/$DB_NAME"
			MYSQL_PWD="$CONF_MYSQL_PWD" mysqldump -u $CONF_MYSQL_USER --single-transaction --skip-lock-tables $DB_NAME -h $CONF_MYSQL_HOST > "$FILEPATH.sql"
			if [ $? -ne 0 ]; then
				log "$(ansi yellow)⚠ Unable to dump database '$(ansi reset)$DB_NAME$(ansi yellow)'.$(ansi reset)"
				continue
			fi
			# compress the dumped file
			log "  $(ansi dim)Compress backup file for '$(ansi reset)$DB_NAME($ansi bold)'.$(ansi reset)"
			if [ "$CONF_Z_TYPE" = "gzip" ]; then
				FILE_EXT="sql.gz"
			elif [ "$CONF_Z_TYPE" = "bzip2" ]; then
				FILE_EXT="sql.bz2"
			else
				FILE_EXT="sql.xz"
			fi
			echo "$FILEPATH.sql" | xargs $CONF_Z_TYPE
			if [ $? -ne 0 ]; then
				log "$(ansi yellow)⚠ Unable to compress file '$(ansi reset)$FILEPATH.sql$(ansi yellow)' using '$CONF_Z_TYPE'.$(ansi reset)"
				# add to list
				FILESLIST="$FILESLIST $FILEPATH.sql"
			else
				# add to list
				FILESLIST="$FILESLIST $FILEPATH.$FILE_EXT"
			fi
		done
		echo
	fi
	# compute checksums
	log "Compute checksums"
	sha256sum "$FILESLIST" > "$CONF_BACKUP_PATH/$CURRENT_DATE/sha256sums"
	if [ $? -ne 0 ]; then
		log "$(ansi yellow)⚠ Unable to create SHA256 checksum file '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_DATE/sha256sums$(ansi yellow)'.$(ansi reset)"
	fi
	# archive on Amazon Glacier
	if [ "$CONF_AWS_GLACIER" = "yes" ]; then
		log "$(ansi bold)Archiving on Amazon Glacier$(ansi reset)"
		aws glacier upload-archive --account-id - --vault-name $CONF_GLACIER_VAULT --body "$CONF_BACKUP_PATH/$CURRENT_DATE/sha256sums" > "$CONF_BACKUP_PATH/$CURRENT_DATE/sha256sums.glacier.json"
		if [ $? -ne 0 ]; then
			log "$(ansi yellow)⚠ Unable to send file '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_DATE/sha256sums$(ansi yellow)' to Amazon Glacier.$(ansi reset)"
		fi
		for FILE in "$FILESLIST"; do
			log "  $(ansi dim)$FILE$(ansi reset)"
			aws glacier upload-archive --account-id - --vault-name $CONF_GLACIER_VAULT --body "$FILE" > "$FILE.glacier.json"
			if [ $? -ne 0 ]; then
				log "$(ansi yellow)⚠ Unable to send file '$(ansi reset)$FILE$(ansi yellow)' to Amazon Glacier.$(ansi reset)"
			fi
		done
	fi
	# archive on Amazon S3
	if [ "$CONF_AWS_S3" = "yes" ]; then
		log "$(ansi bold)Archiving on Amazon S3$(ansi reset)"
		aws s3 sync $CONF_BACKUP_PATH/$CURRENT_DATE s3://$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$CURRENT_DATE
		if [ $? -ne 0 ]; then
			log "$(ansi yellow)⚠ Unable to copy directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_DATE$(ansi yellow)' to Amazon S3 '$(ansi reset)$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$CURRENT_DATE$(ansi yellow)'.$(ansi reset)"
		fi
		echo
	fi
	# purge local files
	if [ "$CONF_LOCAL_PURGE_DELAY" != "" ]; then
		log "$(ansi bold)Purge local files$(ansi reset)"
		# list of delays, each one like "2 days" or "3 weeks:01,03,05"
		DELAYS=$(echo "$CONF_LOCAL_PURGE_DELAY" | tr " " "_" | tr ";" "\n")
		# loop on the delays
		for DELAY in $DELAYS; do
			# extract the delay part, like "2 days" or "3 weeks"
			AGO=$(echo "$DELAY" | cut -d":" -f 1 | tr "_" " ")
			# compute the date of the archive(s) to purge
			PURGE_DATE=`date --date="$AGO ago" +%Y-%m-%d`
			# get the list of hours to delete
			HOURS=$(trim $(echo "$DELAY" | cut -d":" -f 2))
			if [ "$HOURS" = "" ]; then
				# no specified hour, delete the whole day
				log "$(ansi dim)Delete '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE$(ansi dim)'."
				rm -rf "$CONF_BACKUP_PATH/$PURGE_DATE"
				if [ $? -ne 0 ]; then
					log "$(ansi yellow)⚠ Unable to purge local directory '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE$(ansi yellow)'.$(ansi reset)"
				fi
			else
				# loop on the hours
				HOURS=$(echo "$HOURS" | tr "," "\n")
				for HOUR in $HOURS; do
					# get the hour on 2 digits
					HOUR=$(printf "%02d" $(trim "$HOUR"))
					# continue the loop if this hour is less than the current hour, or if the directory was already deleted
					if [ "$HOUR" -gt "$CURRENT_HOUR" ] || [ ! -d "$CONF_BACKUP_PATH/$PURGE_DATE/$HOUR:00" ]; then
						continue;
					fi
					# delete the directory
					log "$(ansi dim)DELETE '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE/$HOUR:00$(ansi dim)'."
					rm -rf "$CONF_BACKUP_PATH/$PURGE_DATE/$HOUR:00"
					if [ $? -ne 0 ]; then
						log "$(ansi yellow)⚠ Unable to purge local directory '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE/$HOUR:00$(ansi yellow)'.$(ansi reset)"
					fi
				done
				# delete the whole day's directory if it's empty
				NBR=`ls -l "$CONF_BACKUP_PATH/$PURGE_DATE" | tail -n +2 | wc -l`
				if [ $NBR -eq 0 ]; then
					log "$(ansi dim)Delete '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE$(ansi dim)'."
					rm -rf "$CONF_BACKUP_PATH/$PURGE_DATE"
					if [ $? -ne 0 ]; then
						log "$(ansi yellow)⚠ Unable to purge local directory '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE$(ansi yellow)'.$(ansi reset)"
					fi
				fi
			fi
		done
	fi
	# purge files on Amazon S3
	if [ "$CONF_S3_PURGE_DELAY" != "" ]; then
		log "$(ansi bold)Purge files on Amazon S3$(ansi reset)"
		# list of delays, each one like "2 days" or "3 weeks:01,03,05"
		DELAYS=$(echo "$CONF_S3_PURGE_DELAY" | tr " " "_" | tr ";" "\n")
		# loop on the delays
		for DELAY in $DELAYS; do
			# extract the delay part, like "2 days" or "3 weeks"
			AGO=$(echo "$DELAY" | cut -d":" -f 1 | tr "_" " ")
			# compute the date of the archive(s) to purge
			PURGE_DATE=`date --date="$AGO ago" +%Y-%m-%d`
			# get the list of hours to delete
			HOURS=$(trim $(echo "$DELAY" | cut -d":" -f 2))
			if [ "$HOURS" = "" ]; then
				# no specified hour, delete the whole day
				log "$(ansi dim)Delete '$(ansi reset)$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE$(ansi dim)'."
				aws s3 rm s3://$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE/ --recursive --exclude "sha256sums" --exclude "*.glacier.json"
				if [ $? -ne 0 ]; then
					log "$(ansi yellow)⚠ Unable to purge S3 directory '$(ansi reset)$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE$(ansi yellow)'.$(ansi reset)"
				fi
			else
				# loop on the hours
				HOURS=$(echo "$HOURS" | tr "," "\n")
				for HOUR in $HOURS; do
					# get the hour on 2 digits
					HOUR=$(printf "%02d" $(trim "$HOUR"))
					# continue the loop if this hour is less than the current hour, or if the directory was already deleted
					if [ "$HOUR" -gt "$CURRENT_HOUR" ] || [ ! -d "$CONF_BACKUP_PATH/$PURGE_DATE/$HOUR:00" ]; then
						continue;
					fi
					# delete the directory
					log "$(ansi dim)DELETE '$(ansi reset)$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE/$HOUR:00$(ansi dim)'."
					aws s3 rm s3://$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE/$HOUR:00/ --recursive --exclude "sha256sums" --exclude "*.glacier.json"
					if [ $? -ne 0 ]; then
						log "$(ansi yellow)⚠ Unable to purge S3 directory '$(ansi reset)$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE/$HOUR:00$(ansi yellow)'.$(ansi reset)"
					fi
				done
			fi
		done
	fi
}

# management of the noansi mode
if [ "$1" = "--noansi" ] || [ "$2" = "--noansi" ] || [ "$3" = "--noansi" ]; then
	NOANSI_MODE=1
fi
# management of configuration file's path
if [ "$2" != "--noansi" ] && [ "$2" != "" ]; then
	CONFIG_FILE_PATH="$2"
fi

# main execution
case "$1" in
	"config")	main_config
	;;
	"exec")		main_process
	;;
	*)		main_usage
	;;
esac

