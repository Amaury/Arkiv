#!/bin/bash

# ARKIV
#
# Simple file archiver, designed to backup local files and MySQL databases and archive them on Amazon S3.
#
# Source code and documentation: https://github.com/Amaury/Arkiv
#
# © 2017, Amaury Bouchard <amaury@amaury.net>

# Path to the configuration file.
# @see	main_usage()
CONFIG_FILE_PATH="~/.arkiv"

# noansi mode
# @see	main_usage()
NOANSI_MODE=0

# trim()
# Remove spaces at the beginning and at the end of a character string.
# @param	string	The string to trim.
trim() {
	RESULT=$(echo "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
	echo $RESULT
}

# filenamize()
# Convert a string that contains a path to a file, and return a string suitable as a file name.
# Replace slashes and spaces by dashes.
# @param	string	The string to modify.
filenamize() {
	RESULT=$(echo "$1" | sed 's/[[:space:]]\+/-/g' | sed 's/\//-/g' | sed -e 's/^-*//' -e 's/-*$//' | sed 's/-\+/-/g')
	echo $RESULT
}

# ansi()
# Write ANSI-compatible statements.
# @param	string	Command:
#			- reset: Remove all decoration.
#			- bold:  Write text in bold.
#			- dim:   Write faint text.
#			- rev:   Write text in reverse video. Could take another parameter with the background color.
#			- under: Write underlined text.
#			- black, red, green, yellow, blue, magenta, cyan, white: Change the text color.
ansi() {
	if [ "$TERM" = "" ] || [ "$NOANSI_MODE" = "1" ]; then
		return
	fi
	case "$1" in
		"reset")	tput sgr0
		;;
		"bold")		tput bold
		;;
		"dim")		tput dim
		;;
		"rev")
			case "$2" in
				"black")	tput setab 0
				;;
				"red")		tput setab 1
				;;
				"green")	tput setab 2
				;;
				"yellow")	tput setab 3
				;;
				"blue")		tput setab 4
				;;
				"magenta")	tput setab 5
				;;
				"cyan")		tput setab 6
				;;
				"white")	tput setab 7
				;;
				*)		tput rev
			esac
		;;
		"under")	tput smul
		;;
		"black")	tput setaf 0
		;;
		"red")		tput setaf 1
		;;
		"green")	tput setaf 2
		;;
		"yellow")	tput setaf 3
		;;
		"blue")		tput setaf 4
		;;
		"magenta")	tput setaf 5
		;;
		"cyan")		tput setaf 6
		;;
		"white")	tput setaf 7
		;;
	esac
}

# log()
# Write a character string with the current date before it.
# @param	string	The text to write.
log() {
	CURDATE=`date +"%Y-%m-%d %H:%M:%S%:z"`
	echo "$(ansi dim)[$CURDATE]$(ansi reset) $1"
}

# main_usage()
# Show help and exit.
main_usage() {
	echo
	echo "$(ansi bold)NAME$(ansi reset)"
	echo "        $(ansi bold)Arkiv$(ansi reset) − Backup and archiving tool"
	echo
	echo "$(ansi bold)SYNOPSIS$(ansi reset)"
	echo "        $(ansi bold)arkiv$(ansi reset) help$(ansi dim)|$(ansi reset)config$(ansi dim)|$(ansi reset)exec [-n|--noansi] [-c $(ansi dim)/path/to/config/file$(ansi reset)|--config$(ansi dim)=/path/to/config/file$(ansi reset)]"
	echo
	echo "$(ansi bold)DESCRIPTION$(ansi reset)"
	echo "        $(ansi bold)Arkiv$(ansi reset) is an easy-to-use tool which provides files and MySQL databases backup, and archiving to Amazon S3 and Amazon Glacier."
	echo
	echo "$(ansi bold)MAIN USAGE$(ansi reset)"
	echo "        $(ansi bold)help$(ansi reset)"
	echo "                Display this help."
	echo "        $(ansi bold)config$(ansi reset)"
	echo "                Create Arkiv's configuration file."
	echo "        $(ansi bold)exec$(ansi reset)"
	echo "                Backup files and databases, archive them and purge old files."
	echo
	echo "$(ansi bold)PARAMETERS$(ansi reset)"
	echo "        $(ansi bold)-n, --noansi$(ansi reset)"
	echo "                Don't use ANSI commands to ouput decorated text (colors, bold, reverse video)."
	echo
	echo "        $(ansi bold)-c$(ansi reset) $(ansi dim)/path/to/config/file$(ansi reset)"
	echo "        $(ansi bold)--config$(ansi reset)$(ansi dim)=/path/to/config/file$(ansi reset)"
	echo "                Path to the configuration file to use instead of '~/.arkiv'."
	echo
	exit 0
}

# _create_config()
# Create the content of the configuration file.
# Uses the global variables defined elsewhere ($CONF_LOCAL_HOSTNAME, $CONF_BACKUP_PATH, etc.).
# @param	string	(optional) Visibility. Replace the MySQL password by an informative message if this parameter is set to "hide".
_create_config() {
	RESULT="CONF_LOCAL_HOSTNAME=\"$CONF_LOCAL_HOSTNAME\"
CONF_Z_TYPE=\"$CONF_Z_TYPE\"
CONF_BACKUP_PATH=\"$CONF_BACKUP_PATH\"
CONF_SRC=\"$CONF_SRC\"
CONF_MYSQL=\"$CONF_MYSQL\""
	if [ "$CONF_MYSQL" = "yes" ]; then
		RESULT="$RESULT
CONF_MYSQL_HOST=\"$CONF_MYSQL_HOST\"
CONF_MYSQL_USER=\"$CONF_MYSQL_USER\""
		if [ "$1" = "hide" ]; then
			RESULT="$RESULT
CONF_MYSQL_PWD=___HIDDEN_PASSWORD___"
		else
			RESULT="$RESULT
CONF_MYSQL_PWD=\"$CONF_MYSQL_PWD\""
		fi
		RESULT="$RESULT
CONF_MYSQL_ALL_DATABASES=\"$CONF_MYSQL_ALL_DATABASES\""
		if [ "$CONF_MYSQL_ALL_DATABASES" = "no" ]; then
			RESULT="$RESULT
CONF_MYSQL_DATABASES=\"$CONF_MYSQL_DATABASES\""
		fi
	fi
	RESULT="$RESULT
CONF_AWS_S3=\"$CONF_AWS_S3\""
	if [ "$CONF_AWS_S3" = "yes" ]; then
		RESULT="$RESULT
CONF_S3_BUCKET=\"$CONF_S3_BUCKET\""
	fi
	RESULT="$RESULT
CONF_AWS_GLACIER=\"$CONF_AWS_GLACIER\""
	if [ "$CONF_AWS_GLACIER" = "yes" ]; then
		RESULT="$RESULT
CONF_GLACIER_VAULT=\"$CONF_GLACIER_VAULT\""
	fi
	RESULT="$RESULT
CONF_LOCAL_PURGE_DELAY=\"$CONF_LOCAL_PURGE_DELAY\""
	if [ "$CONF_AWS_S3" = "yes" ]; then
		RESULT="$RESULT
CONF_S3_PURGE_DELAY=\"$CONF_S3_PURGE_DELAY\""
	fi
	echo "$RESULT"
}

# main_config()
# Manage configuration.
main_config() {
	# splashscreen
	echo
	echo " $(ansi rev)                                         $(ansi reset)"
	echo " $(ansi rev) $(ansi reset)$(ansi rev blue)                                       $(ansi reset)$(ansi rev) $(ansi reset)"
	echo " $(ansi rev) $(ansi reset)$(ansi rev blue)          $(ansi white)$(ansi bold)Arkiv Configuration$(ansi reset)$(ansi rev blue)          $(ansi reset)$(ansi rev) $(ansi reset)"
	echo " $(ansi rev) $(ansi reset)$(ansi rev blue)                                       $(ansi reset)$(ansi rev) $(ansi reset)"
	echo " $(ansi rev)                                         $(ansi reset)"
	echo
	# BASIC
	echo "$(ansi rev yellow) BASIC                   $(ansi reset)"
	# simple mode
	read -p " $(ansi yellow)Do you want to set up Arkiv's simple mode? (one backup per day, every day) [Y/n]$(ansi reset) " ANSWER
	SIMPLE_MODE=$(trim "$ANSWER")
	if [ "$SIMPLE_MODE" = "" ] || [ "$SIMPLE_MODE" = "y" ] || [ "$SIMPLE_MODE" = "Y" ]; then
		SIMPLE_MODE="yes"
	elif [ "$SIMPLE_MODE" = "n" ] || [ "$SIMPLE_MODE" = "N" ]; then
		SIMPLE_MODE="no"
	else
		echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
		exit 1
	fi
	# local host
	HOST=`hostname`
	if [ "$HOST" = "" ]; then
		HOST="localhost"
	fi
	read -p " $(ansi yellow)Local host name? [$HOST]$(ansi reset) " ANSWER
	CONF_LOCAL_HOSTNAME=$(trim "$ANSWER")
	if [ "$CONF_LOCAL_HOSTNAME" = "" ]; then
		CONF_LOCAL_HOSTNAME="$HOST"
	fi
	# compression type
	read -p " $(ansi yellow)Compression type? (gzip|bzip2|xz) [xz]$(ansi reset) " ANSWER
	CONF_Z_TYPE=$(trim "$ANSWER")
	if [ "$CONF_Z_TYPE" != "gzip" ] && [ "$CONF_Z_TYPE" != "bzip2" ]; then
		if [ "$CONF_Z_TYPE" != "" ] && [ "$CONF_Z_TYPE" != "xz" ]; then
			echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
			exit 1
		fi
		CONF_Z_TYPE="xz"
	fi
	# BACKUP
	echo
	echo "$(ansi rev blue) BACKUP                  $(ansi reset)"
	# path to backup
	read -p " $(ansi yellow)Paths (directories and/or files) to backup? (separated with spaces) [/etc /home]$(ansi reset) " ANSWER
	CONF_SRC=$(trim "$ANSWER")
	if [ "$CONF_SRC" = "" ]; then
		CONF_SRC="/etc /home"
	fi
	# check paths
	for SRC in $CONF_SRC; do
		if [ "${SRC:0:1}" != "/" ]; then
			echo " $(ansi red)⛔ All paths must begin with a '$(ansi reset)/$(ansi red)'. ABORT$(ansi reset)"
			exit
		fi
	done
	# MySQL
	CONF_MYSQL="no"
	read -p " $(ansi yellow)Backup MySQL databases? [Y/n]$(ansi reset) " ANSWER
	ANSWER=$(trim "$ANSWER")
	if [ "$ANSWER" = "" ] || [ "$ANSWER" = "y" ] || [ "$ANSWER" = "Y" ]; then
		CONF_MYSQL="yes"
		# check mysqldump
		if ! type mysqldump > /dev/null; then
			echo " $(ansi red)⛔ The 'mysqldump' program is not installed. ABORT$(ansi reset)"
			exit 1
		fi
		# MySQL hostname
		read -p " $(ansi yellow)MySQL hostname? [localhost]$(ansi reset) " ANSWER
		CONF_MYSQL_HOST=$(trim "$ANSWER")
		if [ "$CONF_MYSQL_HOST" = "" ]; then
			CONF_MYSQL_HOST="localhost"
		fi
		# MySQL user
		read -p " $(ansi yellow)MySQL user? [root] $(ansi reset) " ANSWER
		CONF_MYSQL_USER=$(trim "$ANSWER")
		if [ "$CONF_MYSQL_USER" = "" ]; then
			CONF_MYSQL_USER="root"
		fi
		# MySQL password
		read -s -p " $(ansi yellow)MySQL password?$(ansi reset) " ANSWER
		CONF_MYSQL_PWD=$(trim "$ANSWER")
		if [ "$CONF_MYSQL_PWD" = "" ]; then
			echo " $(ansi red)⛔ Empty password. ABORT$(ansi reset)"
			exit 1
		fi
		echo
		# MySQL databases
		read -p " $(ansi yellow)Do you want to backup all databases readable by this user? (otherwise you will have to give a list of database names) [Y/n]$(ansi reset) " ANSWER
		ANSWER=$(trim "$ANSWER")
		CONF_MYSQL_ALL_DATABASES="yes"
		if [ "$ANSWER" = "n" ] || [ "$ANSWER" = "N" ]; then
			CONF_MYSQL_ALL_DATABASES="no"
			read -p " $(ansi yellow)List of databases? (separated with spaces)$(ansi reset) " ANSWER
			CONF_MYSQL_DATABASES=$(trim "$ANSWER")
			if [ "$CONF_MYSQL_DATABASES" = "" ]; then
				echo " $(ansi red)⛔ No database to backup. ABORT$(ansi reset)"
				exit 1
			fi
		fi
	elif [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
		echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
		exit 1
	fi
	# ARCHIVE
	echo
	echo "$(ansi rev magenta) ARCHIVE                 $(ansi reset)"
	# local archive path
	read -p " $(ansi yellow)Path to local archives? [/var/archives]$(ansi reset) " ANSWER
	CONF_BACKUP_PATH=$(trim "$ANSWER")
	if [ "$CONF_BACKUP_PATH" = "" ]; then
		CONF_BACKUP_PATH="/var/archives"
	fi
	CONF_BACKUP_PATH="$(eval realpath "$CONF_BACKUP_PATH")"
	if [ ! -d "$CONF_BACKUP_PATH" ]; then
		read -p " $(ansi yellow)Directory '$(ansi reset)$CONF_BACKUP_PATH$(ansi yellow)' doesn't exist. Create it? [Y/n]$(ansi reset) " ANSWER
		if [ "$ANSWER" = "n" ] || [ "$ANSWER" = "N" ]; then
			echo " $(ansi red)⛔ ABORT$(ansi reset)"
			exit 1
		fi
		if ! mkdir -p "$CONF_BACKUP_PATH"; then
			echo " $(ansi red)⛔ Unable to create directory '$(ansi reset)$CONF_BACKUP_PATH$(ansi red)'. ABORT$(ansi reset)"
			exit 1
		fi
		chmod 600 "$CONF_BACKUP_PATH"
		if [ $? -ne 0 ]; then
			echo " $(ansi red)⛔ Unable to change permissions of directory '$(ansi reset)$CONF_BACKUP_PATH$(ansi red)'. ABORT$(ansi reset)"
			exit 1
		fi
	elif [ ! -w "$CONF_BACKUP_PATH" ]; then
		echo " $(ansi red)⛔ Directory '$(ansi reset)$CONF_BACKUP_PATH$(ansi red)' exists but is not writable. ABORT$(ansi reset)"
		exit 1
	fi
	# Amazon S3 + Glacier
	CONF_AWS_S3="no"
	CONF_AWS_GLACIER="no"
	read -p " $(ansi yellow)Archive to Amazon S3? [Y/n]$(ansi reset) " ANSWER
	if [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
		CONF_AWS_S3="yes"
		# check aws-cli
		if ! type aws > /dev/null; then
			echo " $(ansi red)⛔ The 'AWS-CLI' program is not installed. ABORT$(ansi reset)"
			exit 1
		fi
		# Amazon S3
		read -p " $(ansi yellow)S3 Bucket name?$(ansi reset) " ANSWER
		CONF_S3_BUCKET=$(trim "$ANSWER")
		if [ "$CONF_S3_BUCKET" = "" ]; then
			echo " $(ansi red)⛔ Empty bucket name. ABORT$(ansi reset)"
			exit 1
		fi
		# Amazon Glacier
		read -p " $(ansi yellow)Archive to Amazon Glacier? [Y/n]$(ansi reset) " ANSWER
		if [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
			CONF_AWS_GLACIER="yes"
			read -p " $(ansi yellow)Glacier Vault name?$(ansi reset) " ANSWER
			CONF_GLACIER_VAULT=$(trim "$ANSWER")
			if [ "$CONF_GLACIER_VAULT" = "" ]; then
				echo " $(ansi red)⛔ Empty vault name. ABORT$(ansi reset)"
				exit 1
			fi
		fi
	fi
	# PURGE
	echo
	echo "$(ansi rev red) PURGE                   $(ansi reset)"
	# local purge
	if [ "$SIMPLE_MODE" = "yes" ]; then
		# daily backups
		read -p " $(ansi yellow)Delay for local purge?$(ansi reset) $(ansi dim)(examples: \"$(ansi reset)3 days$(ansi dim)\" \"$(ansi reset)2 weeks$(ansi dim)\" \"$(ansi reset)2 months$(ansi dim)\")$(ansi reset) " ANSWER
	else
		# hourly backups
		echo " $(ansi yellow)Delay for local purge$(ansi reset)"
		echo " $(ansi dim)You can give as many delays as you want, separated by semi-colons.$(ansi reset)"
		echo " $(ansi dim)Each delay could be written like:$(ansi reset)"
		echo " $(ansi dim)   - A number followed by a duration. Examples: \"3 days\", \"2 weeks\", \"2 months\"$(ansi reset)"
		echo " $(ansi dim)   - Same as previous, followed by a colon and some hours to purge (separated by comas). Example: \"2 days:02,04,06,08,10;4 days,01,03,05\"$(ansi reset)"
		echo " $(ansi dim)$(ansi bold)Advice:$(ansi reset)$(ansi dim) Even if you purge on different hours, be sure to purge everything after a given delay.$(ansi reset)"
		echo " $(ansi dim)        Like \"2 days:01,03,05,07,09,11,13,15,17,19,21,23;1 week:02,04,06,10,12,14,18,20,22;2 weeks:08,16;$(ansi bold)1 month$(ansi reset)$(ansi dim)\"$(ansi reset)"
		read ANSWER
	fi
	CONF_LOCAL_PURGE_DELAY=$(trim "$ANSWER")
	if [ "$CONF_LOCAL_PURGE_DELAY" = "" ]; then
		read -p " $(ansi red)⚠ Are you sure you want to never purge any backup file? [y/N]$(ansi reset) " ANSWER
		if [ "$ANSWER" != "y" ] && [ "$ANSWER" != "Y" ]; then
			echo " $(ansi red)⛔ Empty purge delay. ABORT$(ansi reset)"
			exit 1
		fi
	fi
	# S3 purge
	if [ "$CONF_AWS_S3" = "yes" ]; then
		if [ "$SIMPLE_MODE" = "yes" ]; then
			# daily backups
			read -p " $(ansi yellow)Delay for Amazon S3 purge?$(ansi reset) $(ansi dim)(examples: \"$(ansi reset)3 days$(ansi dim)\" \"$(ansi reset)2 weeks$(ansi dim)\" \"$(ansi reset)2 months$(ansi dim)\")$(ansi reset) " ANSWER
		else
			# hourly backups
			echo " $(ansi yellow)Delay for Amazon S3 purge$(ansi reset)"
			echo " $(ansi dim)You can give as many delays as you want, separated by semi-colons.$(ansi reset)"
			echo " $(ansi dim)Each delay could be written like:$(ansi reset)"
			echo " $(ansi dim)   - A number followed by a duration. Examples: \"3 days\", \"2 weeks\", \"2 months\"$(ansi reset)"
			echo " $(ansi dim)   - Same as previous, followed by a colon and some hours to purge (separated by comas). Example: \"2 days:02,04,06,08,10;4 days,01,03,05\"$(ansi reset)"
			echo " $(ansi dim)$(ansi bold)Advice:$(ansi reset)$(ansi dim) Even if you purge on different hours, be sure to purge everything after a given delay.$(ansi reset)"
			echo " $(ansi dim)        Like \"1 week:01,02,03,05,06,07,09,10,11,13,14,15,17,18,19,21,22,23;2 weeks:00,08,16;1 month:12,20;$(ansi bold)2 months$(ansi reset)$(ansi dim)\"$(ansi reset)"
			read ANSWER
		fi
		CONF_S3_PURGE_DELAY=$(trim "$ANSWER")
		if [ "$CONF_S3_PURGE_DELAY" = "" ]; then
			read -p " $(ansi red)⚠ Are you sure you want to never purge any archived file? [y/N] " ANSWER
			if [ "$ANSWER" != "y" ] && [ "$ANSWER" != "Y" ]; then
				echo " $(ansi red)⛔ Empty purge delay. ABORT$(ansi reset)"
				exit 1
			fi
		fi
	fi
	# GENERATED CONFIG
	echo
	echo "$(ansi rev green) CONFIG CHECK            $(ansi reset)"
	# create result
	RESULT="$(_create_config hide)"
	# display result
	echo
	echo " $(ansi under)HERE IS THE CONTENT THAT WILL BE WRITTEN$(ansi reset)"
	echo "$(ansi dim)$RESULT$(ansi reset)"
	echo
	# write content
	read -p " $(ansi yellow)Ready to erase file '$(ansi reset)$CONFIG_FILE_PATH$(ansi yellow)' and rebuild it? [y/N]$(ansi reset) " ANSWER
	ANSWER=$(trim "$ANSWER")
	if [ "$ANSWER" != "y" ] && [ "$ANSWER" != "Y" ]; then
		echo " $(ansi red)⛔ ABORT$(ansi reset)"
		exit 1
	fi
	RESULT="$(_create_config)"
	echo "$RESULT" > "$(eval realpath "$CONFIG_FILE_PATH")"
	if [ $? -ne 0 ]; then
		echo " $(ansi red)⛔ Unable to create the file '$(ansi reset)$CONFIG_FILE_PATH$(ansi red)'. ABORT$(ansi reset)"
		exit 1
	fi
	chmod 600 "$(eval realpath "$CONFIG_FILE_PATH")"
	if [ $? -ne 0 ]; then
		echo " $(ansi yellow)⚠ Unable to set access rights of the file '$(ansi reset)$CONFIG_FILE_PATH$(ansi yellow)'.$(ansi reset)"
	fi
	echo " $(ansi green)✓ The configuration file '$(ansi reset)$CONFIG_FILE_PATH$(ansi green)' was successfully created.$(ansi reset)"
	# CRONTAB
	echo
	echo "$(ansi rev cyan) CRONTAB                 $(ansi reset)"
	IN_CRONTAB=`crontab -l 2>/dev/null | grep arkiv | wc -l`
	if [ "$IN_CRONTAB" != "0" ]; then
		read -p " $(ansi yellow)Arkiv is already defined in Crontab. Do you want to remove it and re-define it? [Y/n]$(ansi reset) " ANSWER
	else
		read -p " $(ansi yellow)Do you want to add execution in Crontab? [Y/n]$(ansi reset) " ANSWER
	fi
	ANSWER=$(trim "$ANSWER")
	if [ "$ANSWER" != "" ] && [ "$ANSWER" != "y" ] && [ "$ANSWER" != "Y" ] && [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
		echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
		exit 1
	fi
	if [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
		if [ "$SIMPLE_MODE" = "yes" ]; then
			CRON_DAYS="*"
			CRON_HOURS="0"
		else
			# execution days
			echo " $(ansi yellow)What days of the month should Arkiv be launched? [*]$(ansi reset)"
			echo " $(ansi dim)Give dates in Crontab format, like \"1,11,21,31\" or \"1-5,11-15,20-25\" or \"*/2\".$(ansi reset)"
			echo " $(ansi dim)Use \"*\" (default value) to launch Arkiv every day.$(ansi reset)"
			read ANSWER
			CRON_DAYS=$(trim "$ANSWER")
			if [ "$CRON_DAYS" = "" ]; then
				CRON_DAYS="*"
			fi
			# execution hours
			echo " $(ansi yellow)What hours of the day should Arkiv be launched? [*]$(ansi reset)"
			echo " $(ansi dim)Give hours in Crontab format, like \"0,4,8,12,16,20\" or \"*/4\" or \"0-4,12-16\".$(ansi reset)"
			echo " $(ansi dim)Use \"*\" (default value) to launch Arkiv every hour.$(ansi reset)"
			read ANSWER
			CRON_HOURS=$(trim "$ANSWER")
			if [ "$CRON_HOURS" = "" ]; then
				CRON_HOURS="*"
			fi
		fi
		# exec path
		CRON_EXEC_PATH="$PWD"
		read -p " $(ansi yellow)Path to the $(ansi reset)Arkiv$(ansi yellow) executable program [$CRON_EXEC_PATH]$(ansi reset) " ANSWER
		ANSWER=$(trim "$ANSWER")
		if [ "$ANSWER" != "" ]; then
			CRON_EXEC_PATH="$ANSWER"
		fi
		if [ ! -x "$CRON_EXEC_PATH/arkiv" ]; then
			echo " $(ansi red)⛔ Unable to find the file '$(ansi reset)$CRON_EXEC_PATH/arkiv$(ansi red)'. ABORT$(ansi reset)"
			exit 1
		fi
		# log path
		read -p " $(ansi yellow)Path to log directory? [/var/log/arkiv]$(ansi reset) " ANSWER
		CRON_LOG_PATH=$(trim "$ANSWER")
		if [ "$CRON_LOG_PATH" = "" ]; then
			CRON_LOG_PATH="/var/log/arkiv"
		fi
		if [ ! -d $CRON_LOG_PATH ]; then
			read -p " $(ansi yellow)Directory '$(ansi reset)$CRON_LOG_PATH$(ansi yellow)' doesn't exist. Create it? [Y/n]$(ansi reset) " ANSWER
			if [ "$ANSWER" = "n" ] || [ "$ANSWER" = "N" ]; then
				echo " $(ansi red)⛔ ABORT$(ansi reset)"
				exit 1
			fi
			if ! mkdir -p $CRON_LOG_PATH; then
				echo " $(ansi red)⛔ Unable to create directory '$(ansi reset)$CRON_LOG_PATH$(ansi red)'. ABORT$(ansi reset)"
				exit 1
			fi
			chmod 770 $CRON_LOG_PATH
		elif [ ! -w $CRON_LOG_PATH ]; then
			echo " $(ansi red)⛔ Directory '$(ansi reset)$CRON_LOG_PATH$(ansi red)' exists but is not writable. ABORT$(ansi reset)"
			exit 1
		fi
		# check
		echo
		echo " $(ansi under)HERE IS THE CRONTAB THAT IS ABOUT TO BE ADDED$(ansi reset)"
		echo "$(ansi dim)# ARKIV backup$(ansi reset)"
		echo "$(ansi dim)0 $CRON_HOURS $CRON_DAYS * * $CRON_EXEC_PATH/arkiv exec >> $CRON_LOG_PATH/arkiv.log 2>&1$(ansi reset)"
		echo
		# add to crontab
		read -p " $(ansi yellow)Is it OK for you? [Y/n]$(ansi reset) " ANSWER
		ANSWER=$(trim "$ANSWER")
		if [ "$ANSWER" = "n" ] || [ "$ANSWER" = "N" ]; then
			echo " $(ansi yellow)⚠ No Crontab installation.$(ansi reset)"
		elif [ "$ANSWER" = "" ] || [ "$ANSWER" = "y" ] || [ "$ANSWER" = "Y" ]; then
			(crontab -l 2>/dev/null | grep -v -e "ARKIV" -e "arkiv"; echo; echo "# ARKIV backup"; echo "0 $CRON_HOURS $CRON_DAYS * * $CRON_EXEC_PATH/arkiv exec >> $CRON_LOG_PATH/arkiv.log 2>&1") | crontab -
			echo " $(ansi green)✓ Arkiv was Successfully added to the Crontab$(ansi reset)"
		else
			echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
			exit 1
		fi
	fi
	# END
	echo
	echo "$(ansi rev) END OF CONFIGURATION    $(ansi reset)"
}

# main_exec()
# Backup files, archive and purge.
main_exec() {
	# get current hour (used during purge process)
	CURRENT_HOUR=`date +"%H"`
	# log
	echo "$(ansi rev)------------------------------------------------------------$(ansi reset)"
	# configuration
	log "$(ansi bold)Start$(ansi reset)"
	log "├ $(ansi dim)Read config file '$(ansi reset)$CONFIG_FILE_PATH$(ansi dim)'.$(ansi reset)"
	if [ ! -r "$(eval realpath "$CONFIG_FILE_PATH")" ]; then
		log "$(ansi red)⛔ Unable to read file '$(ansi reset)$CONFIG_FILE_PATH$(ansi red)'. ABORT$(ansi reset)"
		exit 1
	else
		. "$(eval realpath "$CONFIG_FILE_PATH")"
	fi
	# create destination directory
	CURRENT_PATH=`date +%Y-%m-%d/%H:00`
	log "├ $(ansi dim)Create output directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH$(ansi dim)'.$(ansi reset)"
	mkdir -p "$CONF_BACKUP_PATH/$CURRENT_PATH"
	if [ $? -ne 0 ]; then
		log "$(ansi red)⛔ Unable to create directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH$(ansi red)'. ABORT$(ansi reset)"
		exit 1
	fi
	chmod -R 600 "$CONF_BACKUP_PATH/$CURRENT_PATH"
	if [ $? -ne 0 ]; then
		log "$(ansi red)⛔ Unable to change permissions of directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH$(ansi red)'. ABORT$(ansi reset)"
		exit 1
	fi
	log "└ $(ansi green)Done$(ansi reset)"
	# list of created files
	FILESLIST=""
	# backup files
	if [ "$CONF_SRC" != "" ]; then
		log "$(ansi bold)Backup files$(ansi reset)"
		# loop on paths to backup
		for SRC in $CONF_SRC; do
			log "├ $(ansi dim)Backup path '$(ansi reset)$SRC$(ansi dim)'.$(ansi reset)"
			FILENAME=$(filenamize "$SRC")
			FILEPATH="$CONF_BACKUP_PATH/$CURRENT_PATH/$FILENAME"
			# remove '/' at the beginning of the path to save, and call tar with "-C /" options to avoid the warning "Removing leading `/' from member names"
			SRC="$(echo "$SRC" | sed 's/^\///')"
			if [ "$CONF_Z_TYPE" = "gzip" ]; then
				FILE_EXT="tar.gz"
				tar czf "$FILEPATH.$FILE_EXT" -C / "$SRC"
			elif [ "$CONF_Z_TYPE" = "bzip2" ]; then
				FILE_EXT="tar.bz2"
				tar cjf "$FILEPATH.$FILE_EXT" -C / "$SRC"
			else
				FILE_EXT="tar.xz"
				tar cJf "$FILEPATH.$FILE_EXT" -C / "$SRC"
			fi
			if [ $? -ne 0 ]; then
				log "$(ansi yellow)⚠ Unable to compress path '$(ansi reset)/$SRC$(ansi yellow)' to '$(ansi reset)$FILEPATH.$FILE_EXT$(ansi yellow)'.$(ansi reset)"
			fi
			# add to list
			FILESLIST="$FILESLIST $FILEPATH.$FILE_EXT"
			# change file rights
			chmod 600 "$FILEPATH.$FILE_EXT"
			if [ $? -ne 0 ]; then
				log "$(ansi yellow)⚠ Unable to set permissions of backup file '$(ansi reset)$FILEPATH.$FILE_EXT$(ansi yellow)'.$(ansi reset)"
			fi
		done
		log "└ $(ansi green)Done$(ansi reset)"
	fi
	# backup mysql
	if [ "$CONF_MYSQL" = "yes" ]; then
		log "$(ansi bold)Backup databases$(ansi reset)"
		# fetch the list of databases if needed
		if [ "$CONF_MYSQL_ALL_DATABASES" = "yes" ]; then
			log "├ $(ansi dim)Fetch the list of databases$(ansi reset)"
			CONF_MYSQL_DATABASES=`MYSQL_PWD="$CONF_MYSQL_PWD" mysql -u $CONF_MYSQL_USER -h $CONF_MYSQL_HOST -e "SHOW DATABASES;" | tr -d "| " | grep -v -e Database -e _schema -e mysql`
			if [ $? -ne 0 ]; then
				log "$(ansi yellow)⚠ Unable to fetch the list of databases from MySQL.$(ansi reset)"
			fi
		fi
		# loop on databases
		for DB_NAME in "$CONF_MYSQL_DATABASES"; do
			# dump MySQL database
			log "├ $(ansi dim)Backup database '$(ansi reset)$DB_NAME$(ansi bold)'$(ansi reset)"
			FILEPATH="$CONF_BACKUP_PATH/$CURRENT_PATH/$DB_NAME"
			MYSQL_PWD="$CONF_MYSQL_PWD" mysqldump -u $CONF_MYSQL_USER --single-transaction --skip-lock-tables $DB_NAME -h $CONF_MYSQL_HOST > "$FILEPATH.sql"
			if [ $? -ne 0 ]; then
				log "$(ansi yellow)⚠ Unable to dump database '$(ansi reset)$DB_NAME$(ansi yellow)'.$(ansi reset)"
				continue
			fi
			# compress the dumped file
			log "├ $(ansi dim)Compress backup file for '$(ansi reset)$DB_NAME$(ansi bold)'.$(ansi reset)"
			if [ "$CONF_Z_TYPE" = "gzip" ]; then
				FILE_EXT="sql.gz"
			elif [ "$CONF_Z_TYPE" = "bzip2" ]; then
				FILE_EXT="sql.bz2"
			else
				FILE_EXT="sql.xz"
			fi
			echo "$FILEPATH.sql" | xargs $CONF_Z_TYPE
			if [ $? -ne 0 ]; then
				log "$(ansi yellow)⚠ Unable to compress file '$(ansi reset)$FILEPATH.sql$(ansi yellow)' using '$CONF_Z_TYPE'.$(ansi reset)"
				FILE_EXT="sql"
			fi
			# add to list
			FILESLIST="$FILESLIST $FILEPATH.$FILE_EXT"
			# change file rights
			chmod 600 "$FILEPATH.$FILE_EXT"
			if [ $? -ne 0 ]; then
				log "$(ansi yellow)⚠ Unable to set permissions of backup file '$(ansi reset)$FILEPATH.$FILE_EXT$(ansi yellow)'.$(ansi reset)"
			fi
		done
		log "└ $(ansi green)Done$(ansi reset)"
	fi
	# compute checksums
	log "$(ansi bold)Compute checksums$(ansi reset)"
	sha256sum $FILESLIST > "$CONF_BACKUP_PATH/$CURRENT_PATH/sha256sums"
	if [ $? -ne 0 ]; then
		log "$(ansi yellow)⚠ Unable to create SHA256 checksum file '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/sha256sums$(ansi yellow)'.$(ansi reset)"
	fi
	# change cheksum file rights
	chmod 600 "$CONF_BACKUP_PATH/$CURRENT_PATH/sha256sums"
	if [ $? -ne 0 ]; then
		log "$(ansi yellow)⚠ Unable to set permissions of checksum file '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/sha256sums$(ansi yellow)'.$(ansi reset)"
	fi
	log "└ $(ansi green)Done$(ansi reset)"
	# archive on Amazon Glacier
	if [ "$CONF_AWS_GLACIER" = "yes" ]; then
		log "$(ansi bold)Archiving on Amazon Glacier$(ansi reset)"
		aws glacier upload-archive --account-id - --vault-name $CONF_GLACIER_VAULT --body "$CONF_BACKUP_PATH/$CURRENT_PATH/sha256sums" > "$CONF_BACKUP_PATH/$CURRENT_PATH/sha256sums.glacier.json"
		if [ $? -ne 0 ]; then
			log "$(ansi yellow)⚠ Unable to send file '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/sha256sums$(ansi yellow)' to Amazon Glacier.$(ansi reset)"
		fi
		for FILE in $FILESLIST; do
			log "├ $(ansi dim)Archive file '$(ansi reset)$FILE$(ansi dim)'.$(ansi reset)"
			aws glacier upload-archive --account-id - --vault-name $CONF_GLACIER_VAULT --body "$FILE" > "$FILE.glacier.json"
			if [ $? -ne 0 ]; then
				log "$(ansi yellow)⚠ Unable to send file '$(ansi reset)$FILE$(ansi yellow)' to Amazon Glacier.$(ansi reset)"
			fi
		done
		log "└ $(ansi green)Done$(ansi reset)"
	fi
	# archive on Amazon S3
	if [ "$CONF_AWS_S3" = "yes" ]; then
		log "$(ansi bold)Archiving on Amazon S3$(ansi reset)"
		aws s3 sync $CONF_BACKUP_PATH/$CURRENT_PATH s3://$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$CURRENT_PATH --quiet
		if [ $? -ne 0 ]; then
			log "$(ansi yellow)⚠ Unable to copy directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH$(ansi yellow)' to Amazon S3 '$(ansi reset)$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$CURRENT_PATH$(ansi yellow)'.$(ansi reset)"
		fi
		log "└ $(ansi green)Done$(ansi reset)"
	fi
	# purge local files
	if [ "$CONF_LOCAL_PURGE_DELAY" != "" ]; then
		log "$(ansi bold)Purge local files$(ansi reset)"
		# list of delays, each one like "2 days" or "3 weeks:01,03,05"
		DELAYS=$(echo "$CONF_LOCAL_PURGE_DELAY" | tr " " "_" | tr ";" "\n")
		# loop on the delays
		for DELAY in $DELAYS; do
			# extract the delay part, like "2 days" or "3 weeks"
			AGO=$(echo "$DELAY" | cut -d":" -f 1 | tr "_" " ")
			# compute the date of the archive(s) to purge
			PURGE_DATE=`date --date="$AGO ago" +%Y-%m-%d`
			# check if the directory exists
			if [ ! -d "$CONF_BACKUP_PATH/$PURGE_DATE" ]; then
				continue;
			fi
			# check if there is some specified hours
			if [[ $DELAY != *:* ]]; then
				# no specified hour, delete the whole day
				log "├ $(ansi dim)Delete '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE$(ansi dim)'."
				rm -rf "$CONF_BACKUP_PATH/$PURGE_DATE"
				if [ $? -ne 0 ]; then
					log "$(ansi yellow)⚠ Unable to purge local directory '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE$(ansi yellow)'.$(ansi reset)"
				fi
			else
				# get the list of hours to delete
				HOURS=$(echo "$DELAY" | cut -d":" -f 2)
				HOURS=$(trim "$HOURS")
				if [ "$HOURS" = "" ]; then
					continue
				fi
				# loop on the hours
				HOURS=$(echo "$HOURS" | tr "," "\n")
				for HOUR in $HOURS; do
					# get the hour on 2 digits
					HOUR=$(printf "%02d" $(trim "$HOUR" | sed 's/^0//'))
					# continue the loop if this hour is not equal to the current hour, or if the directory was already deleted
					if [ "$HOUR" != "$CURRENT_HOUR" ] || [ ! -d "$CONF_BACKUP_PATH/$PURGE_DATE/$HOUR:00" ]; then
						continue;
					fi
					# delete the directory
					log "├ $(ansi dim)Delete '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE/$HOUR:00$(ansi dim)'."
					rm -rf "$CONF_BACKUP_PATH/$PURGE_DATE/$HOUR:00"
					if [ $? -ne 0 ]; then
						log "$(ansi yellow)⚠ Unable to purge local directory '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE/$HOUR:00$(ansi yellow)'.$(ansi reset)"
					fi
				done
				# delete the whole day's directory if it's empty
				NBR=`ls -l "$CONF_BACKUP_PATH/$PURGE_DATE" | tail -n +2 | wc -l`
				if [ $NBR -eq 0 ]; then
					log "├ $(ansi dim)Delete '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE$(ansi dim)'."
					rm -rf "$CONF_BACKUP_PATH/$PURGE_DATE"
					if [ $? -ne 0 ]; then
						log "$(ansi yellow)⚠ Unable to purge local directory '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE$(ansi yellow)'.$(ansi reset)"
					fi
				fi
			fi
		done
		log "└ $(ansi green)Done$(ansi reset)"
	fi
	# purge files on Amazon S3
	if [ "$CONF_S3_PURGE_DELAY" != "" ]; then
		log "$(ansi bold)Purge files on Amazon S3$(ansi reset)"
		# list of delays, each one like "2 days" or "3 weeks:01,03,05"
		DELAYS=$(echo "$CONF_S3_PURGE_DELAY" | tr " " "_" | tr ";" "\n")
		# loop on the delays
		for DELAY in $DELAYS; do
			# extract the delay part, like "2 days" or "3 weeks"
			AGO=$(echo "$DELAY" | cut -d":" -f 1 | tr "_" " ")
			# compute the date of the archive(s) to purge
			PURGE_DATE=`date --date="$AGO ago" +%Y-%m-%d`
			# check if there is some specified hours
			if [[ $DELAY != *:* ]]; then
				# no specified hour, delete the whole day
				log "├ $(ansi dim)Delete '$(ansi reset)s3://$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE$(ansi dim)'."
				aws s3 rm s3://$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE/ --recursive --exclude "sha256sums" --exclude "*.glacier.json"
				if [ $? -ne 0 ]; then
					log "$(ansi yellow)⚠ Unable to purge S3 directory '$(ansi reset)$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE$(ansi yellow)'.$(ansi reset)"
				fi
			else
				# get the list of hours to delete
				HOURS=$(echo "$DELAY" | cut -d":" -f 2)
				HOURS=$(trim "$HOURS")
				if [ "$HOURS" = "" ]; then
					continue
				fi
				# loop on the hours
				HOURS=$(echo "$HOURS" | tr "," "\n")
				for HOUR in $HOURS; do
					# get the hour on 2 digits
					HOUR=$(printf "%02d" $(trim "$HOUR" | sed 's/^0//'))
					# continue the loop if this hour is not equal to the current hour
					if [ "$HOUR" != "$CURRENT_HOUR" ]; then
						continue;
					fi
					# delete the directory
					log "├ $(ansi dim)Delete '$(ansi reset)s3://$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE/$HOUR:00$(ansi dim)'."
					aws s3 rm s3://$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE/$HOUR:00/ --recursive --exclude "sha256sums" --exclude "*.glacier.json"
					if [ $? -ne 0 ]; then
						log "$(ansi yellow)⚠ Unable to purge S3 directory '$(ansi reset)$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE/$HOUR:00$(ansi yellow)'.$(ansi reset)"
					fi
				done
			fi
		done
		log "└ $(ansi green)Done$(ansi reset)"
	fi
	log "$(ansi green)✓ End of processing$(ansi reset)"
	echo
}

# parsing command-line options
# @see	https://stackoverflow.com/questions/402377/using-getopts-in-bash-shell-script-to-get-long-and-short-command-line-options/7680682#7680682
# main execution
case "$1" in
	"config")
		EXEC_TYPE="config"
		;;
	"exec")
		EXEC_TYPE="exec"
		;;
	*)
		main_usage
		;;
esac
shift
while getopts ":nc:-:" OPTCHAR; do
	case "$OPTCHAR" in
		"-")
			case "$OPTARG" in
				"noansi")
					echo "--noansi option"
					NOANSI_MODE=1
					;;
				config=*)
					echo "--config option"
					CONFIG_FILE_PATH=${OPTARG#*=}
					;;
				*)
					log "$(ansi red)⛔ Bad command line option '--$OPTARG'. ABORT$(ansi reset)"
					log "$(ansi dim)Try $(ansi reset)$0 help$(ansi dim) to get help.$(ansi reset)"
					exit 1
			esac
			;;
		"n")
			echo "-n option"
			NOANSI_MODE=1
			;;
		"c")
			echo "-c option"
			;;
		*)
			log "$(ansi red)⛔ Bad command line option '-$OPTARG'. ABORT$(ansi reset)"
			log "$(ansi dim)Try $(ansi reset)$0 help$(ansi dim) to get help.$(ansi reset)"
			exit 1
			;;
	esac
done

# main execution
case "EXEC_TYPE" in
	"config")
		main_config
		;;
	"exec")
		main_exec
		;;
	*)
		main_usage
		;;
esac

